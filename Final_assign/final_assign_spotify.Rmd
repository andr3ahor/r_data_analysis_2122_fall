---
title: "Birdbath_final assignment"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

#Intro
Final assignment: Bird bath

The 2021-08-31 TidyTueday dataset is about song popularity on Spotify. There is only one dataset, it is called `commute`. Reproduce the plot below!

The data has not been screened on youtube.

See below as required:
    -Proper textual explanations, and commented code
    -Exploratory data analysis with useful visualizations
    -Testing of hypothesis by building statistical model(s)
    -Verifying that statistical tests are reliable and valid (e.g. residual diagnostics, assumption checks)
    
Az EDA után arra leszek kíváncsi, hogy milyen tényezők határozzák meg legjobban a popularitást /korreláció, majd lineáris regresszió. 
#Végül az elemzések alapján megpróbálok felállítani egy modellt erre.
    
#Dataset
```{r}
spotify_songs <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-01-21/spotify_songs.csv')
library(tidyverse)
library(ggplot2)
library(ggcorrplot)
library(kableExtra)
library(knitr)
library(psych)
library(Hmisc)
library(RColorBrewer)

```

#Tidy
```{r}
#A nagy adathalmazból kiválasztottam azokat a változókat, amikkel dolgozni szeretnék.
spotify.df <- subset(spotify_songs, select=c(2,3,4,7,8, 10,12:23))
spotify.df$track_album_release_date <- substr(spotify.df$track_album_release_date, 0, 4) #dátum redukálása évre


#Hangnem (mode) változó átkódolása: major =dúr, minor =moll
spotify <- spotify.df %>% mutate(mode = recode(mode, 
                                 "1" = "major",
                                 "0" = "minor"))

```
#EDA
```{r}
str(spotify)
summary(spotify)

#NA értékek: összes 10, charachter változókban, melyekkel nem szeretnék dolgozni egyébként sem (trackname,artist)
colSums(is.na(spotify))

#Évek: 1957-2020 
spotify <- spotify.df %>% 
  rename(Year = track_album_release_date)

#Genre fajták és számuk
table(spotify$playlist_genre) #6 genre van: edm, latin, pop, r&b, rap, rock. Nagyjából hasonló számban.

#Popularitás értékek alakulása
summary(spotify.df$track_popularity)

#Látható, hogy a nagyon kiugróan sokan adtak 0 értékelést
ggplot(spotify) +
    aes(x = track_popularity) +
    geom_histogram(bins = 30L) + 
    theme_minimal()

spotify %>% filter(track_popularity < 1) 
```

#Popularitás eloszlások ábrázolása
```{r}
#install.packages("wesanderson")
library(wesanderson)

#Popularitás alakulása az évek során. A popularitás itt azt jelenti, hogy mennyire volt népszerű.
spotify %>% 
    sample_n(1000) %>%
    ggplot() + 
    aes(x=Year, y=track_popularity, color=mode) + 
    geom_point() +
    theme_minimal() +
    labs( title = 'Popularitás alakulása az évek során', subtitle = "(1957-2020)", y= "Popularitás", color = 'Hangnem') + 
    scale_x_discrete(name = NULL, breaks = scales::pretty_breaks(n= 7))

#Popularitás genre alapján, az évek során
spotify %>% 
    sample_n(1000) %>%
    ggplot() + 
    aes(x=Year, y=track_popularity, color= playlist_genre) + 
    geom_point() + 
    theme_minimal() +
    labs( title = 'Popularitás alakulása műfajok szerint', subtitle = "(1957-2020)",y= "Popularitás", color = 'Műfaj') +
    scale_x_discrete(name = NULL,breaks = scales::pretty_breaks(n= 7)) 
```


Választott bemeneti változók:
```{r}
# Dataset for LM
data <- subset(spotify, select=c(3,7,8, 10,12:17))

```


#Előfeltételek 1: kollinearitás/multikoll. kizárása
```{r}
cordata <- cor(data)
cordata <- round(cordata,2)
rcorr<-rcorr(as.matrix(data))

pvalues <- round(rcorr$P, 2) #minden észlelt korreláció szingifikáns, ám többségük gyenge.

#Az alábbi változók közötti közepes erősségű kapcsolat van, de mivel ez sem problémás szint (0.8-0.9 fölötti), ezért bent hagytam.
# energy - acousticness: -0.54
# energy - loudness: 0.68

library(viridis)
library(corrplot)
ggcorrplot(cordata, 
           hc.order = FALSE, 
           type = "upper",
           lab = FALSE) + scale_fill_viridis()

corrplot(cordata, method = "color",  
         type = "lower", order = "original", 
         addCoef.col = "black", 
         tl.col = "darkblue", tl.srt = 45,
         sig.level = 0.01,  
         diag = FALSE) #ábrák mentve a mappába is

```

#Előfeltételek2: Szóráshomogenitás
```{r}
#install.packages("onewaytests")
library(car)
library(onewaytests)

#Levene's test, ami nem követeli meg a normális eloszlást
homog.test(track_popularity ~ mode, data = spotify, method = "Bartlett")
bartlett$p.value #nem sérül a szóráshomogenitás

#Elvégeztem a robosztus tesztet is, ami alapján szintén nem sérül
homog.test(track_popularity ~ mode, data = spotify, method = "Levene")

```

#Előfeltételek3: Lineritás prediktorok és kimeneti változó között
```{r}
#Külön végeztem el a változókra, mert nagyon kiolvashatatlan volt egyben a sok ábra
plot(lm(track_popularity ~ danceability, data = data)) 
plot(lm(track_popularity ~ energy, data = data)) 
plot(lm(track_popularity ~ loudness, data = data)) #nem teljesül
plot(lm(track_popularity ~ speechiness, data = data)) #nem teljesül
plot(lm(track_popularity ~ acousticness, data = data)) 
plot(lm(track_popularity ~ instrumentalness, data = data))
plot(lm(track_popularity ~ liveness, data = data)) #nem teljesül
plot(lm(track_popularity ~ valence, data = data)) 
plot(lm(track_popularity ~ tempo, data = data)) #nem teljesül


#A residual vs fitt ábrák mentve mappába /plot, 1 ábrák. A végső számolásba nem kerültek bele az alábbi változók: loudness, speechiness, liveness, tempo

```

#Reziduális hibák ne korreláljanak / Durbin-Watson test
```{r}
model <- lm(track_popularity ~ danceability+energy+acousticness+instrumentalness+valence, data=data)
dw<-durbinWatsonTest(model) 
#Látom, hogy ez nem teljesül, szingifkáns p értéket kapunk. Ugyanakkor ezen a szinten már nem látom át, hogy ezt pontosan hogyan is lehetne megoldani (valamiféle lag korrekcióval). Ha ez most egy éles kutatás lenne, akkor valószínűleg tanácsot kérnék. Most azonban ettől eltekintek, és lefuttatom a végső elemzést.
```

#Többszörös lineáris regresszió futtatása
```{r}
#A model tehát:
model <- lm(track_popularity ~ danceability+energy+acousticness+instrumentalness+valence, data=data)
summary(model)
#A valence nem magyarázza szingifikánsan a popularitást. Ki is veszem, és újra futtatom:

model_new <- lm(track_popularity ~ danceability+energy+acousticness+instrumentalness, data=data)

#R-squared

#RSE
sigma(model)/mean(data$track_popularity)

#Értelmezések

```

#Discussion
```{r}

```

