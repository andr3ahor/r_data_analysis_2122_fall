---
title: "Spotify"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

#Intro
Final assignment: Spotify

The 2021-08-31 TidyTueday dataset is about song popularity on Spotify. This is a 2020 dataset, the years mean only the appearance of the song. There is only one dataset, it is called `commute`. Reproduce the plot below!

The data has not been screened on youtube.

See below as required:
    -Proper textual explanations, and commented code
    -Exploratory data analysis with useful visualizations
    -Testing of hypothesis by building statistical model(s)
    -Verifying that statistical tests are reliable and valid (e.g. residual diagnostics, assumption checks)
    
Az EDA után arra leszek kíváncsi, hogy milyen tényezők határozzák meg legjobban a popularitást /korreláció, majd lineáris regresszió. 
#Végül az elemzések alapján megpróbálok felállítani egy modellt erre.
    
#Dataset
```{r}
spotify_songs <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-01-21/spotify_songs.csv')
library(tidyverse)
library(ggplot2)
library(ggcorrplot)
library(kableExtra)
library(knitr)
library(psych)
library(Hmisc)
library(RColorBrewer)

```

#Tidy
```{r}
#A nagy adathalmazból kiválasztottam azokat a változókat, amikkel dolgozni szeretnék.
spotify.df <- subset(spotify_songs, select=c(2,3,4,7,8, 10,12:23))
spotify.df$track_album_release_date <- substr(spotify.df$track_album_release_date, 0, 4) #dátum redukálása évre


#Hangnem (mode) változó átkódolása: major =dúr, minor =moll
spotify <- spotify.df %>% mutate(mode = recode(mode, 
                                 "1" = "major",
                                 "0" = "minor"))

```
#EDA
```{r}
str(spotify)
summary(spotify)

#NA értékek: összes 10, charachter változókban, melyekkel nem szeretnék dolgozni egyébként sem (trackname,artist)
colSums(is.na(spotify))

#Évek: 1957-2020 
spotify <- spotify  %>% 
    rename(Year = track_album_release_date)

#Genre fajták és számuk
table(spotify$playlist_genre) #6 genre van: edm, latin, pop, r&b, rap, rock. Nagyjából hasonló számban.

#Popularitás értékek alakulása
summary(spotify.df$track_popularity) #medián: 45 ez fontos lesz még később

#Látható, hogy a nagyon kiugróan sokan adtak 0 értékelést
ggplot(spotify) +
    aes(x = track_popularity) +
    geom_histogram(bins = 30L) + 
    theme_minimal()

spotify %>% filter(track_popularity < 1) 

#Ebből sajnos nem tiszta, hogy a 0 érték az abból adódik-e,hogy az adott dalt nem hallgatták. Hiszen nem tudjuk, hogy a popularity érték egy átlag-e?

describe(spotify$track_popularity)

IQR(spotify$track_popularity)
Tmin = 24-(1.5*38) 
Tmax = 62+(1.5*38)
spotify$track_popularity[which(spotify$track_popularity < Tmin | spotify$track_popularity > Tmax)] #IQR alapján is 0 az outlier

#Én végül úgy döntöttem, hogy ezt az outliert én szeretném moderálni. Mivel ez a 0 érték nem köthető a megjelenés évéhez sem (ahogy reméltem), ezért capping módszert választottam megoldásként:


qn = quantile(spotify$track_popularity, c(0.05, 0.95), na.rm = FALSE)
df = within(spotify, { track_popularity = ifelse(track_popularity < qn[1], qn[1], track_popularity)
track_popularity = ifelse(track_popularity > qn[2], qn[2], track_popularity)})

ggplot(df) +
    aes(x = track_popularity) +
    geom_histogram(bins = 30L) + 
    theme_minimal()

#Ez is megtöri az eloszlást picit.Más megoldást nem tudtam kitalálni, úgyhogy random módon kitöröltem 2500 sort, amikben a popularity = 0.
library(data.table)
DT <- data.table(spotify)
spotify <- DT[-sample(which(spotify$track_popularity==0), 2500)]

ggplot(spotify) +
    aes(x = track_popularity) +
    geom_histogram(bins = 30L) + 
    theme_minimal()  

#Outlier ellenőrzés:
describe(spotify$track_popularity) #1Q: 31, 3Q:63

IQR(spotify$track_popularity) #32
Tmin = 31-(1.5*32) 
Tmax = 63+(1.5*32)
spotify$track_popularity[which(spotify$track_popularity < Tmin | spotify$track_popularity > Tmax)] #még mindig a 0, de az eloszlás egész tűrhető, így hagyom
```

#Popularitás eloszlások ábrázolása
```{r}
#install.packages("wesanderson")
library(wesanderson)

#Popularitás alakulása az évek során. A popularitás itt azt jelenti, hogy mennyire volt népszerű.
spotify %>% 
    sample_n(1000) %>%
    ggplot() + 
    aes(x=Year, y=track_popularity, color=mode) + 
    geom_point() +
    theme_minimal() +
    labs( title = 'Popularitás alakulása az évek során', subtitle = "(1957-2020)", y= "Popularitás", color = 'Hangnem') + 
    scale_x_discrete(name = NULL, breaks = scales::pretty_breaks(n= 7))

#Popularitás genre alapján, az évek során
spotify %>% 
    sample_n(1000) %>%
    ggplot() + 
    aes(x=Year, y=track_popularity, color= playlist_genre) + 
    geom_point() + 
    theme_minimal() +
    labs( title = 'Popularitás alakulása műfajok szerint', subtitle = "(1957-2020)",y= "Popularitás", color = 'Műfaj') +
    scale_x_discrete(name = NULL,breaks = scales::pretty_breaks(n= 7)) 
```


Választott bemeneti változók:
```{r}
# Dataset for LM
data <- subset(spotify, select=c(3,7,8, 10,12:17))

```


#Előfeltételek 1: kollinearitás/multikoll. kizárása
```{r}
cordata <- cor(data)
cordata <- round(cordata,2)
rcorr<-rcorr(as.matrix(data))

pvalues <- round(rcorr$P, 2) #minden észlelt korreláció szingifikáns, ám többségük gyenge.

#Az alábbi változók közötti közepes erősségű kapcsolat van, de mivel ez sem problémás szint (0.8-0.9 fölötti), ezért bent hagytam.
# energy - acousticness: -0.54
# energy - loudness: 0.68

library(viridis)
library(corrplot)
ggcorrplot(cordata, 
           hc.order = FALSE, 
           type = "upper",
           lab = FALSE) + scale_fill_viridis()

corrplot(cordata, method = "color",  
         type = "lower", order = "original", 
         addCoef.col = "black", 
         tl.col = "darkblue", tl.srt = 45,
         sig.level = 0.01,  
         diag = FALSE) #ábrák mentve a mappába is

```

#Előfeltételek2: Szóráshomogenitás
```{r}
#install.packages("onewaytests")
library(car)
library(onewaytests)

#Levene's test, ami nem követeli meg a normális eloszlást
bartlett <- homog.test(track_popularity ~ mode, data = spotify, method = "Bartlett")
bartlett$p.value #nem sérül a szóráshomogenitás

#Elvégeztem a robosztus tesztet is, ami alapján szintén nem sérül
homog.test(track_popularity ~ mode, data = spotify, method = "Levene") # p=0.61

```

#Előfeltételek3: Lineritás prediktorok és kimeneti változó között
```{r}
#Külön végeztem el a változókra, mert nagyon kiolvashatatlan volt egyben a sok ábra
plot(lm(track_popularity ~ danceability, data = data)) 
plot(lm(track_popularity ~ energy, data = data)) 
plot(lm(track_popularity ~ loudness, data = data)) #nem teljesül
plot(lm(track_popularity ~ speechiness, data = data)) #nem teljesül
plot(lm(track_popularity ~ acousticness, data = data)) 
plot(lm(track_popularity ~ instrumentalness, data = data))
plot(lm(track_popularity ~ liveness, data = data)) #nem teljesül
plot(lm(track_popularity ~ valence, data = data)) 
plot(lm(track_popularity ~ tempo, data = data)) #nem teljesül


#A residual vs fitt ábrák mentve mappába /plot, 1 ábrák. A végső számolásba nem kerültek bele az alábbi változók: loudness, speechiness, liveness, tempo

```

#Reziduális hibák ne korreláljanak / Durbin-Watson test
```{r}
model <- lm(track_popularity ~ danceability+energy+acousticness+instrumentalness+valence, data=data)
dw<-durbinWatsonTest(model) 
#Látom, hogy ez nem teljesül, szingifkáns p értéket kapunk. Ugyanakkor ezen a szinten már nem látom át, hogy ezt pontosan hogyan is lehetne megoldani (valamiféle lag korrekcióval). Ha ez most egy éles kutatás lenne, akkor valószínűleg tanácsot kérnék. Most azonban ettől eltekintek, és lefuttatom a végső elemzést.
```

#Többszörös lineáris regresszió futtatása
```{r}
#A model tehát:
model <- lm(track_popularity ~ danceability+energy+acousticness+instrumentalness+valence, data=data)
summary(model) # popularity = 46.2 + 8.1*danceability + -8*energy +3.1*acousticness + -14.9*instrumentalness + 1.4*valence


#R-squared adjusted: Az érték azt jelzi, hogy a modellünk nem magyarárra igazán nagy részét a kimeneti változónak.

#RSE
sigma(model)/mean(data$track_popularity) #elég magas az érték, ezek szerint a modell elég pontatlan a jelen minta alapján
```

#Discussion
```{r}
#Értelmezések: a popularitást leginkább a táncolhatóság, az energiaszint, az akusztikusság, az instrumentáltság és a valencia határozza meg. Problémás a modellünk, mert nem amgyarázza a variancia nagy részét és elég pontatlan is a használt mintán. Az outlierek és a reziduális hibák korrelációja is állhat e-mögött. Az is fontos, hogy nagyon eltérő skálákon mérték a vizsgált prediktor változókat. Lehet, hogy ezek standardizálása is javítana a pontosságon.

#Én úgy gondolom, hogy érdemes lenne egy kisebb mintán megnézni, hogy mi határozza emg leginkább a popularitást. Hiszen ahogy láthattuk, a zenei ízlés változott az évek során. Elképzelhető, hogy ez a változó mögöttesen de meghatározta az én elemzésemet is. Így vagy genre hatását lenne érdemes a továbbiakban kibontani, vagy leszűkíteni egy adott "korszakra" a mintát és azon belül vizsgálódni.



```

